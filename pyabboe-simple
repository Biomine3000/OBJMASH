#!/usr/bin/env python3
# -*- mode: Python; indent: 4 -*-
import socket as socket_module
import time
import select
import json
import logging
import sys
import collections

METADATA_MAX_SIZE = 2048
PAYLOAD_MAX_SIZE = 10485760 # 10 megabytes
SELECT_TIMEOUT = 10

# Data structures and helpers
Client = collections.namedtuple("Client", ["address", "send_buffer", "receive_buffer", "disconnected"])

def with_send_buffer(client, buffer):
    return Client(address=client.address, send_buffer=buffer,
                  receive_buffer=client.receive_buffer, disconnected=client.disconnected)

def with_receive_buffer(client, buffer):
    return Client(address=client.address, send_buffer=client.send_buffer,
                  receive_buffer=buffer, disconnected=client.disconnected)

def make_client(address):
    return Client(address=address, send_buffer=bytes(), receive_buffer=bytes(), disconnected=False)

def disconnect_client(client):
    return Client(address=client.address, send_buffer=client.send_buffer,
                  receive_buffer=client.receive_buffer, disconnected=True)

def remove_disconnected(clients, logger):
    disconnected = {client_socket:clients[client_socket] for client_socket in clients
                    if clients[client_socket].disconnected}

    for client_socket, client in disconnected.items():
        logger.warn("Disconnecting {0}".format(client))
        client_socket.close()

    return {client_socket:clients[client_socket] for client_socket in clients
            if not clients[client_socket].disconnected}

# Handlers
def handle_reading_sockets(clients, sockets, logger):
    incoming_objects = []
    for socket in sockets:
        if socket not in clients:
            client_socket, address = socket.accept()
            client_socket.setblocking(False)
            clients[client_socket] = make_client(address)
            logger.info("New client {0}".format(clients[client_socket]))
        else:
            client = clients[socket]
            try:
                disconnect = False
                incoming_objects, client, disconnect = handle_read(socket, client, logger)
                clients[socket] = client
            except Exception as e:
                logger.warning("handle_read, client {0}: {1}".format(client, e))
                disconnect = True
            finally:
                if disconnect:
                    clients[socket] = disconnect_client(client)

    return incoming_objects, clients

def handle_writing_sockets(clients, sockets, logger):
    for socket in sockets:
        client = clients[socket]
        try:
            disconnect = False
            disconnect, client = handle_write(socket, client, logger)
            clients[socket] = client
        except Exception as e:
            logger.warning("handle_write, client {0}: {1}".format(client, e))
            disconnect = True
        finally:
            if disconnect:
                clients[socket] = disconnect_client(client)

    return clients

def handle_write(socket, client, logger):
    disconnect = False
    sent_bytes = 0
    try:
        sent_bytes = socket.send(client.send_buffer)
    except socket_module.error as se:
        logger.warning("Received {0} from {1}".format(se, client))
        disconnect = True
    return disconnect, with_send_buffer(client, client.send_buffer[sent_bytes:])


def first_nul(buffer):
    for i in range(len(buffer)):
        if buffer[i] == 0:
            return i

def parse_metadata(buffer):
    nul_index = first_nul(buffer)
    return (json.loads(buffer[:nul_index].decode('utf-8', 'strict')),
            buffer[nul_index + 1:])

def handle_read(socket, client, logger):
    disconnect = False

    metadata_received = False
    if len(client.receive_buffer) > 0:
        if first_nul(client.receive_buffer) is not None:
            metadata_received = True

    if metadata_received is False:
        bytes_left = METADATA_MAX_SIZE - len(client.receive_buffer)
        if bytes_left == 0:
            logger.warning("No metadata received within the METADATA_MAX_SIZE limit.")
            return [], client, True

        received = socket.recv(bytes_left)

        # On the read list and nothing to read. Signals disconnection.
        if len(received) == 0:
            logger.info("Client disconnected.")
            return [], client, True

        client = with_receive_buffer(client, client.receive_buffer + received)

    if len(client.receive_buffer) > 0:
        nul_index = first_nul(client.receive_buffer)
        if nul_index is not None:
            metadata_received = True

    if not metadata_received:
        return [], client, False

    objects = []
    while True:
        metadata, receive_buffer = parse_metadata(client.receive_buffer)
        client = with_receive_buffer(client, receive_buffer)
        objects.append((metadata, None))

        if metadata.get('size', 0) > 0:
            raise Exception("Cannot handle payloads yet")

        nul_index = first_nul(client.receive_buffer)
        if nul_index is None:
            break

    return objects, client, False


def main():
    # Set up logging
    logging.basicConfig(level=logging.DEBUG)
    logger = logging.getLogger(sys.argv[0])

    # Open listening socket
    listening_socket = socket_module.socket(socket_module.AF_INET, socket_module.SOCK_STREAM)
    listening_socket.bind(("localhost", 7890))
    listening_socket.listen(5)

    reading_sockets = [listening_socket]
    writing_sockets = []

    initial_clients = {}
    current_clients = initial_clients
    while True:
        logger.debug(repr([reading_sockets, writing_sockets]))

        try:
            (reading_sockets,
             writing_sockets, _) = select.select(reading_sockets, writing_sockets, [],
                                                 SELECT_TIMEOUT)
        except KeyboardInterrupt as kbi:
            for client_socket in current_clients:
                client_socket.close()
            listening_socket.close()
            raise kbi

        logger.debug(repr([reading_sockets, writing_sockets]))

        incoming_objects, current_clients = handle_reading_sockets(current_clients, reading_sockets, logger)
        # print(incoming_objects)
        current_clients = handle_writing_sockets(current_clients, writing_sockets, logger)

        current_clients = remove_disconnected(current_clients, logger)

        # Sockets for next round
        reading_sockets = [listening_socket]
        writing_sockets = []
        for client_socket, client in current_clients.items():
            reading_sockets.append(client_socket)

            if len(client.send_buffer) > 0:
                writing_sockets.append(client_socket)

        logger.debug('----')

if __name__ == '__main__':
    main()
