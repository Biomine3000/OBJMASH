#!/usr/bin/env python3
# -*- mode: Python; indent: 4 -*-
import socket as socket_module
import time
import select
import json
import logging
import sys
import collections
import traceback
import email.utils

NUL = '\x00'.encode('utf-8')

METADATA_MAX_SIZE = 2048
PAYLOAD_MAX_SIZE = 10485760 # 10 megabytes
MAX_OBJECT_SIZE = METADATA_MAX_SIZE + 1 + PAYLOAD_MAX_SIZE
SELECT_TIMEOUT = 10

# Data structures and helpers
_ClientBase = collections.namedtuple("Client", ["address", "send_buffer", "receive_buffer",
                                                "disconnected", "subscriptions", "receive_mode"])

logger_basename = sys.argv[0].strip('.').strip('/')
def lg(name=None):
    if name is None:
        return logging.getLogger(logger_basename)
    else:
        return logging.getLogger(logger_basename + "." + name)

class Client(_ClientBase):
    def _attr_substituted(self, attr_name, value):
        # attrs = vars(self)
        attrs = self._asdict()
        attrs[attr_name] = value
        return attrs

    def from_address(address):
        return Client(address=address, send_buffer=bytes(), receive_buffer=bytes(),
                      disconnected=False, subscriptions=None, receive_mode=None)

    def with_send_buffer(self, buffer):
        return Client(**self._attr_substituted('send_buffer', buffer))

    def with_receive_buffer(self, buffer):
        return Client(**self._attr_substituted('receive_buffer', buffer))

    def with_subscriptions(self, subscriptions):
        return Client(**self._attr_substituted('subscriptions', subscriptions))

    def with_receive_mode(self, receive_mode):
        return Client(**self._attr_substituted('receive_mode', receive_mode))

    def as_disconnected(self):
        return Client(**self._attr_substituted('disconnected', True))

class BusinessObject(object):
    def __init__(self, metadata_dict, payload):
        self.metadata = metadata_dict
        self.id = metadata_dict.get('id', email.utils.make_msgid())
        self.payload = payload
        self.size = metadata_dict.get('size', 0)
        self.content_type = metadata_dict.get('type', None)
        self.event = metadata_dict.get('event', None)

    def __str__(self):
        return "<{0} {1}>".format(self.__class__.__name__, self.content_type)

    def __hash__(self):
        return self.id.__hash__()

    def __eq__(self, other):
        return self.__hash__() == other.__hash__()

    def serialize(self):
        self.metadata['id'] = self.id
        self.metadata['size'] = self.size
        if self.content_type is not None:
            self.metadata['type'] = str(self.content_type)

        ret = bytearray(json.dumps(self.metadata).encode('utf-8'))
        ret += NUL
        if self.size > 0:
            ret.extend(self.payload)

        return ret

def without_disconnected(clients):
    return {client_socket:clients[client_socket]
            for client_socket in clients
            if not clients[client_socket].disconnected}

def with_closed_sockets(clients):
    logger = lg()
    for socket, client in clients.items():
        if client.disconnected:
            logger.warn("Disconnecting {0}".format(client))
            socket.close()
    return clients

# Handlers
def handle_reading_sockets(clients, sockets):
    logger = lg('read')
    incoming_objects = []
    for socket in sockets:
        if socket not in clients:
            client_socket, address = socket.accept()
            client_socket.setblocking(False)
            clients[client_socket] = Client.from_address(address)
            logger.info("New client {0}".format(clients[client_socket]))
        else:
            client = clients[socket]
            try:
                incoming_objects, client = handle_read(socket, client)
                clients[socket] = client
            except Exception as e:
                logger.warning("handle_read, client {0}: {1}".format(client, traceback.format_exc()))
                clients[socket] = client.as_disconnected()

    return incoming_objects, clients

def handle_writing_sockets(clients, sockets):
    logger = lg('write')
    for socket in sockets:
        client = clients[socket]
        try:
            client = handle_write(socket, client)
            clients[socket] = client
        except Exception as e:
            logger.warning("handle_write, client {0}: {1}".format(client, e))
            clients[socket] = client.as_disconnected()

    return clients

def handle_write(socket, client):
    logger = lg('write')
    sent_bytes = 0
    try:
        sent_bytes = socket.send(client.send_buffer)
        lg('traffic').debug("Sent {0} bytes to {1}".format(sent_bytes, client))
    except socket_module.error as se:
        logger.warning("Received {0} from {1}".format(se, client))
        return client.as_disconnected()

    return client.with_send_buffer(client.send_buffer[sent_bytes:])

def parse_metadata(buffer, first_nul_index):
    return (json.loads(buffer[0:first_nul_index].decode('utf-8', 'strict')),
            buffer[first_nul_index + 1:])

def is_metadata_received(client):
    def first_nul(buffer):
        for i in range(min(METADATA_MAX_SIZE, len(buffer))):
            if buffer[i] == 0:
                return i

    if len(client.receive_buffer) > 0:
        first_nul_index = first_nul(client.receive_buffer)
        if first_nul_index is not None:
            return True, first_nul_index
    return False, None

def handle_read(socket, client):
    logger = lg('read')

    received = socket.recv(MAX_OBJECT_SIZE)
    if len(received) == 0:
        lg('read').info("{0} disconnected".format(client))
        return [], client.as_disconnected()

    client = client.with_receive_buffer(client.receive_buffer + received)

    metadata_received, first_nul_index = is_metadata_received(client)
    if not metadata_received and len(client.receive_buffer) >= METADATA_MAX_SIZE:
        lg('read').warning("No payload within METADATA_MAX_SIZE.")
        return [], client.as_disconnected()

    if not metadata_received:
        return [], client

    # Pump objects out of the receive buffer
    objects = []
    while len(client.receive_buffer) > 0:
        metadata_received, first_nul_index = is_metadata_received(client)
        if not metadata_received:
            break

        metadata, remaining_buffer = parse_metadata(client.receive_buffer, first_nul_index)

        try:
            payload_length = int(metadata['size'])
        except:
            payload_length = None

        if payload_length is None or payload_length == 0:
            objects.append((socket, BusinessObject(metadata, None)))
            client = client.with_receive_buffer(remaining_buffer)
            continue

        if len(remaining_buffer) < payload_length:
            break

        payload = remaining_buffer[0:payload_length]
        objects.append((socket, BusinessObject(metadata, payload)))
        client = client.with_receive_buffer(remaining_buffer[payload_length:])

    return objects, client


def routing_decision(metadata, rules):
    def match(matcher, matchable):
        if matcher is None or matchable is None:
            return False

        matcher_parts = matcher.split('/')
        matchable_parts = matchable.split('/')

        for index, matcher_part in enumerate(matcher_parts):
            if matcher_part == '*':
                return True

            if index >= len(matchable_parts):
                return False
            matchable_part = matchable_parts[index]
            if matcher_part != matchable_part:
                return False

        return True


    PASS = False # pass written in lowercase is a keyword in Python

    for rule in rules:
        is_negative_rule = rule.startswith('!')
        if is_negative_rule:
            rule = rule[1:]

        if rule.startswith('#'):
            rule = rule[1:]
            for nature in metadata.get('natures', []):
                if match(rule, nature): # nature == rule:
                    PASS = not is_negative_rule
                    break

        elif rule.startswith('@'):
            rule = rule[1:]
            event = metadata.get('event', None)
            if event is not None and match(rule, event): # message.event == rule:
                PASS = not is_negative_rule

        elif rule == '*' or match(rule, metadata.get('type', None)):
            PASS = not is_negative_rule

    return PASS

def subscribe_client(clients, client, socket, subscription):
    subscriptions = subscription.metadata.get('subscriptions', ['*'])
    receive_mode = subscription.metadata.get('receive-mode', 'all')

    metadata = {'event': 'routing/subscribe/reply',
                         'subscriptions': subscriptions,
                         'receive-mode': receive_mode}

    if 'id' in subscription.metadata:
        metadata['in-reply-to'] = subscription.metadata['id']

    client = client \
        .with_subscriptions(subscriptions) \
        .with_receive_mode(receive_mode) \
        .with_send_buffer(BusinessObject(metadata, None).serialize())
    result_clients = dict(clients)
    result_clients[socket] = client

    lg('subscribe-client').info("{0} subscribed".format(client))

    notification_object = BusinessObject(
        {'event': 'routing/subscribe/notification',
         'subscriptions': subscriptions,
         'receive-mode': receive_mode},
        None)
    for other_socket, other_client in clients.items():
        if other_socket == socket:
            continue
        if other_client.receive_mode == 'none':
            continue

        result_clients[other_socket] = other_client \
            .with_send_buffer(client.send_buffer + notification_object.serialize())

    return result_clients, client

def respond_to_ping(client, ping):
    metadata = {'event': 'pong'}
    if 'id' in ping.metadata:
        metadata['in-reply-to'] = ping.metadata['id']
    return client.with_send_buffer(client.send_buffer + BusinessObject(metadata, None).serialize())

def handle_object(clients, socket_tuple):
    socket, obj = socket_tuple
    client = clients[socket]
    result_clients = dict(clients)
    event = obj.metadata.get('event', None)

    if client.subscriptions is None:
        if event == 'routing/subscribe':
            result_clients, client = subscribe_client(result_clients, client, socket, obj)
            # TODO: routing announcement
        else:
            client = client.as_disconnected()
            lg('handle-object').warning(
                "Unsubscribed client {0} sent something else than a subscription ({1})".format(client, event))
    else:
        if event == 'ping':
            client = respond_to_ping(client, obj)
        else:
            for other_socket, other_client in result_clients.items():
                if other_client.receive_mode == 'events_only' and event is None:
                    continue
                elif other_client.receive_mode == 'none':
                    continue
                elif other_client.receive_mode == 'no_echo' and other_socket == socket:
                    continue
                # unspecified receive_mode is considered 'all'

                should_send = routing_decision(obj.metadata, other_client.subscriptions)
                if should_send is True:
                    result_clients[other_socket] = other_client.with_send_buffer(
                        other_client.send_buffer + obj.serialize())

    result_clients[socket] = client
    return result_clients

def handle_objects(clients, socket_tuples):
    result_clients = dict(clients)
    for socket_tuple in socket_tuples:
        result_clients = handle_object(clients, socket_tuple)
    return result_clients

def main():
    # Set up logging
    logging.basicConfig(level=logging.DEBUG)
    # logger = lg('select')

    # Open listening socket
    listening_socket = socket_module.socket(socket_module.AF_INET, socket_module.SOCK_STREAM)
    listening_socket.bind(("localhost", 7890))
    listening_socket.listen(5)

    reading_sockets = [listening_socket]
    writing_sockets = []

    initial_clients = {}
    current_clients = initial_clients
    while True:
        # logger.debug(repr([reading_sockets, writing_sockets]))

        try:
            (reading_sockets,
             writing_sockets, _) = select.select(reading_sockets, writing_sockets, [],
                                                 SELECT_TIMEOUT)
        except KeyboardInterrupt as kbi:
            for client_socket in current_clients:
                client_socket.close()
            listening_socket.close()
            raise kbi
        except Exception as e:
            for client_socket in current_clients:
                client_socket.close()
            listening_socket.close()
            raise e

        # logger.debug(repr([reading_sockets, writing_sockets]))

        objects, current_clients = handle_reading_sockets(current_clients, reading_sockets)
        current_clients = without_disconnected(with_closed_sockets(current_clients))
        current_clients = handle_objects(current_clients, objects)
        current_clients = handle_writing_sockets(current_clients, writing_sockets)
        current_clients = without_disconnected(with_closed_sockets(current_clients))

        # Sockets for next round
        reading_sockets = [listening_socket]
        writing_sockets = []
        for client_socket, client in current_clients.items():
            reading_sockets.append(client_socket)

            if len(client.send_buffer) > 0:
                writing_sockets.append(client_socket)

        # logger.debug('----')

if __name__ == '__main__':
    main()
