#!/usr/bin/env python3
# -*- mode: Python; indent: 4 -*-
import socket as socket_module
import time
import select
import json
import logging
import sys
import collections

METADATA_MAX_SIZE = 2048
PAYLOAD_MAX_SIZE = 10485760 # 10 megabytes
SELECT_TIMEOUT = 10

# Data structures and helpers
_ClientBase = collections.namedtuple("Client", ["address", "send_buffer", "receive_buffer",
                                                "disconnected", "subscriptions", "receive_mode"])

bn = sys.argv[0].strip('.').strip('/')
def lg(name=None):
    if name is None:
        return logging.getLogger(bn)
    else:
        return logging.getLogger(bn + "." + name)

class Client(_ClientBase):
    def _attr_substituted(self, attr_name, value):
        # attrs = vars(self)
        attrs = self._asdict()
        attrs[attr_name] = value
        return attrs

    def from_address(address):
        return Client(address=address, send_buffer=bytes(), receive_buffer=bytes(),
                      disconnected=False, subscriptions=None, receive_mode=None)

    def with_send_buffer(self, buffer):
        return Client(**self._attr_substituted('send_buffer', buffer))

    def with_receive_buffer(self, buffer):
        return Client(**self._attr_substituted('receive_buffer', buffer))

    def with_subscriptions(self, subscriptions):
        return Client(**self._attr_substituted('subscriptions', subscriptions))

    def with_receive_mode(self, receive_mode):
        return Client(**self._attr_substituted('receive_mode', receive_mode))

    def as_disconnected(self):
        print(self._attr_substituted('disconnected', True))
        return Client(**self._attr_substituted('disconnected', True))


def without_disconnected(clients):
    return {client_socket:clients[client_socket]
            for client_socket in clients
            if not clients[client_socket].disconnected}

def with_closed_sockets(clients):
    logger = lg()
    for socket, client in clients.items():
        if client.disconnected:
            logger.warn("Disconnecting {0}".format(client))
            socket.close()
    return clients

# Handlers
def handle_reading_sockets(clients, sockets):
    logger = lg('read')
    incoming_objects = []
    for socket in sockets:
        if socket not in clients:
            client_socket, address = socket.accept()
            client_socket.setblocking(False)
            clients[client_socket] = Client.from_address(address)
            logger.info("New client {0}".format(clients[client_socket]))
        else:
            client = clients[socket]
            try:
                incoming_objects, client = handle_read(socket, client)
                clients[socket] = client
            except Exception as e:
                logger.warning("handle_read, client {0}: {1}".format(client, e))
                clients[socket] = client.as_disconnected()

    return incoming_objects, clients

def handle_writing_sockets(clients, sockets):
    logger = lg('write')
    for socket in sockets:
        client = clients[socket]
        try:
            client = handle_write(socket, client)
            clients[socket] = client
        except Exception as e:
            logger.warning("handle_write, client {0}: {1}".format(client, e))
            clients[socket] = client.as_disconnected()

    return clients

def handle_write(socket, client):
    logger = lg('write')
    sent_bytes = 0
    try:
        sent_bytes = socket.send(client.send_buffer)
        lg('traffic').debug("Sent {0} bytes to {1}".format(sent_bytes, client))
    except socket_module.error as se:
        logger.warning("Received {0} from {1}".format(se, client))
        return client.as_disconnected()

    return client.with_send_buffer(client.send_buffer[sent_bytes:])


def first_nul(buffer):
    for i in range(len(buffer)):
        if buffer[i] == 0:
            return i

def parse_metadata(buffer):
    nul_index = first_nul(buffer)
    return (json.loads(buffer[:nul_index].decode('utf-8', 'strict')),
            buffer[nul_index + 1:])

def handle_read(socket, client):
    logger = lg('read')
    metadata_received = False
    if len(client.receive_buffer) > 0:
        if first_nul(client.receive_buffer) is not None:
            metadata_received = True

    if metadata_received is False:
        bytes_left = METADATA_MAX_SIZE - len(client.receive_buffer)
        if bytes_left == 0:
            logger.warning("No metadata received within the METADATA_MAX_SIZE limit.")
            return [], client.as_disconnected()

        received = socket.recv(bytes_left)

        # On the read list and nothing to read. Signals disconnection.
        if len(received) == 0:
            logger.info("Client disconnected.")
            return [], client.as_disconnected()

        client = client.with_receive_buffer(client.receive_buffer + received)
        lg('traffic').debug("Received {0} bytes from {1}".format(len(received), client))

    if len(client.receive_buffer) > 0:
        nul_index = first_nul(client.receive_buffer)
        if nul_index is not None:
            metadata_received = True

    if not metadata_received:
        return [], client

    objects = []
    while True:
        metadata, receive_buffer = parse_metadata(client.receive_buffer)
        client = client.with_receive_buffer(receive_buffer)

        if metadata.get('size', 0) > 0:
            raise Exception("Cannot handle payloads yet")

        objects.append((socket, metadata, None))

        nul_index = first_nul(client.receive_buffer)
        if nul_index is None:
            break

    return objects, client

def handle_subscription_event(socket, client, metadata):
    # TODO validate subscriptions / receive-mode?
    subscriptions = metadata.get('subscriptions', ['*'])
    receive_mode = metadata.get('receive-mode', 'all')

    response_metadata = {'event': 'routing/subscribe/reply',
                         'receive-mode': receive_mode,
                         'subscriptions': subscriptions}
    if 'id' in metadata:
        response_metadata['in-reply-to'] = metadata['id']

    return client \
        .with_subscriptions(subscriptions) \
        .with_receive_mode(receive_mode) \
        .with_send_buffer(client.send_buffer + json.dumps(response_metadata).encode('utf-8') + '\\0'.encode('utf-8'))

def handle_ping_event(socket, client, metadata):
    return client \
        .with_send_buffer(client.send_buffer + json.dumps({'event': 'pong'}))

def handle_events(objects, clients):
    logger = lg()
    multiplexable_objects = []
    response_events = []
    result_clients = dict(clients)
    for client_socket, metadata, payload in objects:
        if not 'event' in metadata:
            multiplexable_objects.append((client_socket, metadata, payload))
            continue

        client = clients.get(client_socket, None)
        if client is None:
            raise Exception("Event source client not in clients: inconsistent state")

        event_type = metadata.get('event', None)

        if event_type == 'routing/subscribe':
            client = handle_subscription_event(client_socket, client, metadata)
            logger.debug('{0} subscribed'.format(client))
            result_clients[client_socket] = client
            response_events.append(({'event': 'routing/subscribe/notification'}))
        elif event_type == 'ping':
            client = handle_ping_event(client_socket, client, metadata)
            result_clients[client_socket] = client

    return multiplexable_objects, response_events, result_clients

def multiplex(clients, objects):
    logger = lg('multiplex')
    for obj in objects:
        _, metadata, payload = obj
        if metadata.get('size', 0) == 0:
            bts = json.dumps(metadata).encode('utf-8') + '\\0'.encode('utf-8')
        else:
            bts = json.dumps(metadata).encode('utf-8') + '\\0'.encode('utf-8') + payload

        for socket, client in clients.items():
            logger.debug('Sending {0} to {1}'.format(obj, client))
            clients[socket] = client \
                .with_send_buffer(client.send_buffer + bts)
    return clients

def main():
    # Set up logging
    logging.basicConfig(level=logging.DEBUG)
    logger = lg('select')

    # Open listening socket
    listening_socket = socket_module.socket(socket_module.AF_INET, socket_module.SOCK_STREAM)
    listening_socket.bind(("localhost", 7890))
    listening_socket.listen(5)

    reading_sockets = [listening_socket]
    writing_sockets = []

    initial_clients = {}
    current_clients = initial_clients
    while True:
        logger.debug(repr([reading_sockets, writing_sockets]))

        try:
            (reading_sockets,
             writing_sockets, _) = select.select(reading_sockets, writing_sockets, [],
                                                 SELECT_TIMEOUT)
        except KeyboardInterrupt as kbi:
            for client_socket in current_clients:
                client_socket.close()
            listening_socket.close()
            raise kbi

        logger.debug(repr([reading_sockets, writing_sockets]))

        incoming_objects, current_clients = handle_reading_sockets(current_clients, reading_sockets)
        current_clients = without_disconnected(with_closed_sockets(current_clients))

        multiplexable_objects, response_events, current_clients = handle_events(incoming_objects, current_clients)

        current_clients = multiplex(current_clients, multiplexable_objects)

        current_clients = handle_writing_sockets(current_clients, writing_sockets)
        current_clients = without_disconnected(with_closed_sockets(current_clients))

        # Sockets for next round
        reading_sockets = [listening_socket]
        writing_sockets = []
        for client_socket, client in current_clients.items():
            reading_sockets.append(client_socket)

            if len(client.send_buffer) > 0:
                writing_sockets.append(client_socket)

        logger.debug('----')

if __name__ == '__main__':
    main()
